#include <stdlib.h>
#include <string.h>
#include "js_libs.h"

static jerry_value_t empty_constructor(const jerry_value_t func_val,
                                       const jerry_value_t this_val,
                                       const jerry_value_t argv[],
                                       const jerry_length_t argc) {
    (void) func_val;
    (void) this_val;
    (void) argv;
    (void) argc;

    return jerry_create_undefined();
}

{% for library in libraries.values() -%}
    {% for handle in library.function_handles.values() -%}
static char function_handle_next_function_name_{{ library.name }}_{{ handle.name }}[256] = {'\0'};
static {{ handle.return_type }} function_handle_internal_function_{{ library.name }}_{{ handle.name }}(
        {% if handle.parameters|length == 0 %}void{% endif %}
        {% for parameter in handle.parameters.values() -%}
    {{ parameter.type }} {{ parameter.name }}{% if not loop.last %}, {% endif %}
        {%- endfor %}
) {
    jerry_value_t global_object = jerry_get_global_object();
    jerry_value_t name = jerry_create_string((const jerry_char_t *) function_handle_next_function_name_{{ library.name }}_{{ handle.name }});
    jerry_value_t func = jerry_get_property(global_object, name);
    //TODO error handling

    jerry_value_t args[{{ [handle.parameters|length, 1]|max }}];
        {%- for param in handle.parameters.values() %}
            {% if param.is_number() %}
    args[{{ loop.index0 }}] = jerry_create_number({{ param.name }});
            {% elif param.is_string() %}
    args[{{ loop.index0 }}] = jerry_create_string((const jerry_char_t*) {{ param.name }});
            {% elif param.is_byte_array() %}
                {% if param.length_parameter not in handle.parameters %}
                    {% raise "library '" ~ library.name ~ "', function handle'" ~ handle.name ~ "', parameter '" ~ param.name ~ "': length parameter '" ~ param.length_parameter ~ "' does not exist as parameter" %}
                {% endif %}
                {% if not handle.parameters[param.length_parameter].is_number() %}
                    {% raise "library '" ~ library.name ~ "', function handle'" ~ handle.name ~ "', parameter '" ~ param.name ~ "': length parameter '" ~ param.length_parameter ~ "' is not a number" %}
                {% endif %}
    if ({{ param.name }} != NULL) {
        args[{{ loop.index0 }}] = jerry_create_string_sz((const jerry_char_t*) {{ param.name }}, {{ param.length_parameter }});
    } else {
        args[{{ loop.index0 }}] = jerry_create_null();
    }
            {% else %}
                {% raise "library '" ~ library.name ~ "', function handle '" ~ handle.name ~ "', parameter '" ~ param.name ~ "': unsupported type '" ~ param.type ~ "' (Maybe it is a function handle? Function handles as parameters of function handles not supported yet.)" %}
            {% endif %}
        {%- endfor %}

    jerry_value_t res_value = jerry_call_function(func, global_object, args, {{ handle.parameters|length }});
    //TODO check type at runtime

        {% if handle.return_type != 'void' %}
            {% if handle.returns_number() -%}
        {{ handle.return_type }} res = ({{ handle.return_type }}) jerry_get_number_value(res_value);
            {% else %}
                {% raise "library '" ~ library.name ~ "', function handle '" ~ handle.name ~ "', return type: unsupported type '" ~ handle.return_type ~ "' (Maybe it is a function handle? Function handles as parameters of function handles not supported yet.)" %}
            {%- endif %}
        {% endif %}

    jerry_release_value(global_object);
    jerry_release_value(name);
    jerry_release_value(func);
        {%- for param in handle.parameters.values() %}
    jerry_release_value(args[{{ loop.index0 }}]);
        {%- endfor %}
    jerry_release_value(res_value);

        {% if handle.return_type != 'void' -%}
    return res;
        {%- endif %}
}
    {%- endfor %}

    {% for function in library.functions.values() %}
static jerry_value_t {{ library.name }}_{{ function.name }}_native(const jerry_value_t func_val,
                                                const jerry_value_t this_val,
                                                const jerry_value_t argv[],
                                                const jerry_length_t argc) {
    (void) func_val;
    (void) this_val;
    (void) argc;

    {% for parameter in function.parameters.values() -%}
        {% if parameter.is_function_handle() %}
    jerry_value_t value_{{ parameter.name }} = jerry_value_to_string(argv[{{ loop.index0 }}]);
    size_t size_{{ parameter.name }} = jerry_get_string_size(value_{{ parameter.name }});
    char* {{ parameter.name }} = calloc(size_{{ parameter.name }} + 1, sizeof(char));
    jerry_string_to_char_buffer(value_{{ parameter.name }}, (jerry_char_t*) {{ parameter.name }}, size_{{ parameter.name }});
    jerry_release_value(value_{{ parameter.name }});
    strcpy(function_handle_next_function_name_{{ library.name }}_{{ library.function_handles[parameter.type].name }}, {{ parameter.name }}); //TODO this is like next level unsafe :D
    free({{ parameter.name }});
        {% elif parameter.is_number() %}
    {{ parameter.type }} {{ parameter.name }} = ({{ parameter.type }}) jerry_get_number_value(argv[{{ loop.index0 }}]);
        {% elif parameter.is_string() or parameter.is_byte_array() %}
            {# if byte array, we need to ensure there is a length parameter, and it is of number type #}
            {% if parameter.is_byte_array() %}
                {% if parameter.length_parameter not in function.parameters %}
                    {% raise "library '" ~ library.name ~ "', function '" ~ function.name ~ "', parameter '" ~ parameter.name ~ "': length parameter '" ~ parameter.length_parameter ~ "' does not exist as parameter" %}
                {% endif %}
                {% if not function.parameters[parameter.length_parameter].is_number() %}
                    {% raise "library '" ~ library.name ~ "', function '" ~ function.name ~ "', parameter '" ~ parameter.name ~ "': length parameter '" ~ parameter.length_parameter ~ "' is not a number" %}
                {% endif %}
            {% endif %}
    char* {{ parameter.name}} = NULL;
    if (!jerry_value_is_null(argv[{{ loop.index0 }}])) {
        jerry_value_t value_{{ parameter.name }} = jerry_value_to_string(argv[{{ loop.index0 }}]);
        size_t size_{{ parameter.name }} = jerry_get_string_size(value_{{ parameter.name }});
        {{ parameter.name }} = (char*) calloc(size_{{ parameter.name }} + 1, sizeof(char));
        jerry_string_to_char_buffer(value_{{ parameter.name }}, (jerry_char_t*) {{ parameter.name }}, size_{{ parameter.name }});
        jerry_release_value(value_{{ parameter.name }});
        //TODO error handling
    }
        {% else %}
            {% raise "library '" ~ library.name ~ "', function '" ~ function.name ~ "', parameter '" ~ parameter.name ~ "': unsupported type '" ~ parameter.type ~ "'" %}
        {% endif %}
    {%- endfor %}

    {% if function.return_type != 'void' -%}{{ function.return_type }} res = {% endif %}{{ function.original_name }}(
    {%- for parameter in function.parameters.values() -%}
        {%- if parameter.is_function_handle() %}
        function_handle_internal_function_{{ library.name }}_{{ library.function_handles[parameter.type].name }}{% if not loop.last %}, {% endif %}
        {%- elif parameter.is_string() or parameter.is_byte_array() %}
        ({{ parameter.type }}) {{ parameter.name }}{% if not loop.last %}, {% endif %}
        {%- else %}
        {{ parameter.name }}{% if not loop.last %}, {% endif %}
        {%- endif %}
    {%- endfor %}
    );

    // manual memory management
    {% for parameter in function.parameters.values() -%}
        {% if parameter.is_string() or parameter.is_byte_array() %}
    free({{ parameter.name }});
        {% endif %}
    {%- endfor %}

    {% if function.return_type == 'void' -%}
    return jerry_create_undefined();
    {%- elif function.returns_number() -%}
    return jerry_create_number(res);
    {%- else -%}
         {% raise "library '" ~ library.name ~ "', function '" ~ function.name ~ "', return type: unsupported type '" ~ handle.return_type ~ "' (Maybe it is a function handle? Function handles as return types are not supported yet.)" %}
    {%- endif %}
}
    {% endfor %}
{% endfor %}

{% for library in libraries.values() -%}
int js_libs_register_{{ library.name }}_natives(void) {
    jerry_value_t constructor = jerry_create_external_function(empty_constructor);
    jerry_value_t library_object = jerry_construct_object(constructor, NULL, 0);

    {%- for function in library.functions.values() %}
    {
        jerry_value_t property_name_function = jerry_create_string((const jerry_char_t*) ("{{ function.name }}"));
        jerry_value_t property_value_function = jerry_create_external_function({{ library.name }}_{{ function.name }}_native);
        jerry_value_t res = jerry_set_property(library_object, property_name_function, property_value_function);
        //TODO error handling

        jerry_release_value(property_name_function);
        jerry_release_value(property_value_function);
        jerry_release_value(res);
    }
    {%- endfor %}

    {%- for name, value in library.constants.items() %}
    {
        jerry_value_t property_name_constant = jerry_create_string((const jerry_char_t*) ("{{ library.get_constant_identifier(name) }}"));
        {% if value is string %}
        jerry_value_t property_value_constant = jerry_create_string((const jerry_char_t*) ("{{ value }}"));
        {% elif value is number %}
        jerry_value_t property_value_constant = jerry_create_number({{ value }});
        {% else %}
            {% raise "library '" ~ library.name ~ "', constant '" ~ name ~ "': unsupported type (only strings and numbers)" %}
        {% endif %}
        jerry_value_t res = jerry_set_property(library_object, property_name_constant, property_value_constant);
        //TODO error handling

        jerry_release_value(property_name_constant);
        jerry_release_value(property_value_constant);
        jerry_release_value(res);
    }
    {%- endfor %}

    jerry_value_t global_object = jerry_get_global_object();
    jerry_value_t property_name_library = jerry_create_string((const jerry_char_t*) ("{{ library.name }}"));
    jerry_value_t res = jerry_set_property(global_object, property_name_library, library_object);
    //TODO error handling

    jerry_release_value(constructor);
    jerry_release_value(library_object);
    jerry_release_value(global_object);
    jerry_release_value(property_name_library);
    jerry_release_value(res);

    return {{ library.functions|length }};
}
{% endfor %}

void js_libs_extract_error_message(jerry_value_t error_value) {
    if (!jerry_value_is_error(error_value)) {
        printf("Provided value is not an error object.\n");
        return;
    }

    jerry_value_t error_obj = jerry_get_value_from_error(error_value, true);

    jerry_value_t message_prop_name = jerry_create_string((const jerry_char_t*)"message");
    jerry_value_t message_value = jerry_get_property(error_obj, message_prop_name);

    if (jerry_value_is_string(message_value)) {
        jerry_size_t message_size = jerry_get_string_size(message_value);
        char *message_buffer = (char *)malloc(message_size + 1);
        if (message_buffer) {
            jerry_string_to_char_buffer(message_value, (jerry_char_t *)message_buffer, message_size);
            message_buffer[message_size] = '\0';

            printf("Error message: %s\n", message_buffer);

            free(message_buffer);
        }
    } else {
        printf("Error object does not have a 'message' property or it is not a string.\n");
    }

    jerry_release_value(message_value);
    jerry_release_value(message_prop_name);
    jerry_release_value(error_obj);
}